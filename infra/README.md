# keycloak環境構築

* 一例としてAWSに構築する場合の手順を記載します。AzureやGCP等、他のクラウドサービスを利用する場合は設定値や手順が異なる場合があります。必要に応じてご対応をお願いします。

## AWSリソース作成

### VPC

1. ブラウザでAWS Management Consoleを開き、画面上部の検索欄に「vpc」と入力し、サービスの「VPC」をクリックする
2. 画面上部の「VPCを作成」ボタンをクリックする
3. 「VPCの設定の作成するリソース」で、「VPCなど」を選択する
4. 「名前タグの自動生成」を有効にし、下記の入力欄にリソース名を入力する\
(他リソース(プライベートサブネットなど)にも入力したリソース名が適応)
5. 「IPv4 CIDR ブロック」で下記の入力欄にIPアドレスを入力する
6. 「IPv6 CIDR ブロック」で「IPv6 CIDR ブロックなし」を選択する
7. 「テナンシー」は「デフォルト」を選択する
8. 「アベイラビリティゾーン (AZ) の数」で「3」を選択する
9. 「パブリックサブネットの数」で「3」を選択する
10. 「プライベートサブネットの数」で「3」を選択する
11. 「NATゲートウェイ」で「1AZ内」を選択する
12. 「VPCエンドポイント」で「なし」を選択する
13. 「DNSオプション」で「DNS ホスト名を有効化」、「DNS 解決を有効化」を有効にする
14. 必要に応じて「追加のタグ」から「新しいタグを追加」をクリックし、タグを入力する
15. 右にある「VPCを作成」ボタンをクリックする
16. 作成後に「お使いのVPC」から作成したVPCがあるかを確認する

### セキュリティグループ(EKS/RDSに設定)

* ブラウザでAWS Management Consoleを開き、画面上部の検索欄に「セキュリティグループ」と入力し、機能の中で「VPCの機能」とある「セキュリティグループ」をクリックする
* EKSとRDSに設定するため2つ作成するが、途中まで共通の手順で作成する

#### 共通の手順

  1. 画面右上にある「セキュリティグループを作成」ボタンをクリックする
  2. 「基本的な詳細」の「セキュリティグループ名」の入力欄にセキュリティグループ名を入力する
  3. 「VPC」の入力欄にVPCのリソース名を入力し、表示されたVPCを選択

#### EKS用

  1. インバウンドルールの「タイプ」で「すべてのトラフィック」を選択する
  2. インバウンドルールの「ソース」で「Anywhere-IPv4」を選択する
  3. 下にスクロールし、「新規タグの追加」をクリックする
  4. 「キー」に「Name」、「値」にセキュリティグループ名を入力する
  5. 「セキュリティグループを作成」ボタンをクリックする

#### RDS用

  1. インバウンドルールの「タイプ」で「PostgreSQL」を選択する
  2. インバウンドルールの「ソース」で「Anywhere-IPv4」を選択する
  3. 下にスクロールし、「新規タグの追加」をクリックする
  4. 「キー」に「Name」、「値」にセキュリティグループ名を入力する
  5. 「セキュリティグループを作成」ボタンをクリックする

### ECR

#### ※途中AWS CLI使う手順があるため、必要に応じてターミナルソフト等にAWS CLIをインストール

* AWS CLIのインストール方法 \
  <https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html#getting-started-install-instructions>

1. ブラウザでAWS Management Consoleを開き、画面上部の検索欄に「ecr」と入力し、機能の「リポジトリ」をクリックする
2. 画面右上の「リポジトリを作成」ボタンをクリックする
3. 一般設定の「可視性設定」で「プライベート」を選択する
4. 「リポジトリ名」の下記入力欄にリポジトリ名を入力する
5. 「タグのイミュータビリティ」を「無効」に設定する
6. イメージスキャンの設定の「プッシュ時にスキャン」を「無効」に設定する
7. 暗号化設定の「KMS暗号化」を「無効」に設定する
8. 「リポジトリを作成」ボタンをクリックする
9. プライベートリポジトリが作成されたことを確認する
10. プライベートリポジトリのURIをコピーして控えておく
11. ターミナルソフトを開き、下記コマンドを実行する(`[]`の中を修正)
    > aws ecr get-login-password --region [対象のリージョンコード] | docker login --username AWS --password-stdin [手順10で控えたURI]
12. 「Login Succeeded」が出力されることを確認する

    ```
    WARNING! Your password will be stored unencrypted in /home/username/.docker/config.json.
    Configure a credential helper to remove this warning.
    See https://docs.docker.com/engine/reference/commandline/login/#credentials-store
    Login Succeeded
    ```

13. 次いで下記コマンドを実行する(`[]`の中を修正)
    > docker push [手順10で控えたURI].dkr.ecr.[対象のリージョンコード].amazonaws.com/[手順4で入力したリポジトリ名]:latest
14. ターミナルソフト上でエラーが起きていないことを確認する
15. ECRの画面に戻り、作成したリポジトリを選択してイメージがプッシュされていることを確認する

### RDS

* ブラウザでAWS Management Consoleを開き、画面上部の検索欄に「rds」と入力し、サービスの「RDS」をクリックする

#### 1. サブネットグループの設定

1. 左のナビゲーターから「サブネットグループ」をクリックする
2. 画面右上の「DB サブネットグループを作成」ボタンをクリックする
3. サブネットグループの詳細から「名前」にサブネットグループ名を入力する
4. 必要に応じて「説明」を入力する
5. 「VPC」から作成したVPCを選択する
6. サブネットを追加の「アベイラビリティゾーン」で、表示されている3つのチェックボックス全てを有効にする
7. 「サブネット」で表示されている中から、プライベートサブネットのチェックボックスのみ有効にする
8. 「作成」ボタンをクリックする

    #### プライベートサブネットの確認方法

        a. ブラウザでAWS Management Consoleを開き、画面上部の検索欄に「vpc」と入力し、サービスの「VPC」をクリックする
        b. 左のナビゲーターから「サブネット」をクリックする
        c. 画面上部の検索欄に「(VPCのリソース名)-subnet-private」で検索
        d. 結果からタブの列にあるサブネットIDを控える(本手順でVPCを作成した場合、3件が結果として表示される)

#### 2. RDSの作成

1. 画面上部の「データベースの作成」ボタンをクリックする
2. データベース作成方法を選択から「標準作成」を選択する
3. エンジンのオプションのエンジンのタイプから「Aurora (PostgreSQL Compatible)」を選択する
4. 「利用可能なバージョン」のセレクトボックスの最下部にある最新版のPostgreSQLを選択する\
   (2023年7月時点で最新版は `Aurora PostgreSQL (Compatible with PostgreSQL 15.3)`)
5. テンプレートから「開発/テスト」を選択する
6. 設定の「DB クラスター識別子」で下記入力欄にDBクラスター名を入力する
7. 「マスターユーザー名」で下記入力欄に「postgres」と入力する
8. 「パスワードの自動生成」を有効にする
9. Cluster storage configuration の「Configuration options」で「Aurora Standard」を選択する
10. インスタンスの設定の「DB インスタンスクラス」から「Serverless v2」を選択する
11. 最小ACUに「0.5」、最大ACUに「16」と入力 (必要に応じて調整)
12. 可用性と耐久性から「Aurora レプリカを作成しない」を選択する
13. 接続の「コンピューティングリソース」から「EC2 コンピューティングリソースに接続しない」を選択する
14. 「ネットワークタイプ」から「IPv4」を選択する
15. 「Virtual Private Cloud (VPC)」から作成したVPCを選択する
16. 「パブリックアクセス」で「なし」を選択する
17. 「VPC セキュリティグループ (ファイアウォール)」で「既存の選択」を選択する
18. 「既存の VPC セキュリティグループ」から作成したRDS用のセキュリティグループを選択する
19. 「Babelfish の設定」、「データベース認証」は初期設定のままスキップ(※チェックボックスは無効のまま)
20. モニタリングの「Performance Insights」から「Performance Insights をオンにする」を有効にする
21. 「保存期間」で「7日(無料利用枠)」を選択する
22. 「追加設定」をクリックし、「拡張モニタリングの有効化」を無効にする
23. 下に表示されている「▶ 追加設定」をクリックする
24. 「データベースの選択肢」から「最初のデータベース名」で「keycloak」と入力する
25. 「DB クラスターのパラメータグループ」~「フェイルオーバー優先順位」は初期設定のままスキップ
26. 「バックアップ」から「7日間」を選択
27. 「スナップショットにタグをコピー」を有効にする
28. 「暗号化」の「暗号を有効化」を有効にする
29. 「AWS KMSキー」は「(default)aws/rds」を選択する
30. 「ログのエクスポート」の「PostgreSQL ログ」は無効にする
31. 「メンテナンス」から「マイナーバージョン自動アップグレードの有効化」を無効にする
32. 「メンテナンスウィンドウ」で「ウィンドウを選択」を選択する
33. メンテナンスする曜日を設定する(※設定した期間RDSは停止)
34. 必要に応じて「削除保護の有効化」を有効/無効にする
35. 「データベースの作成」ボタンをクリックする(※RDSが作成できるまで約20分程度かかる)
36. 作成後に画面上部の緑のバーから「接続の詳細の表示」をクリックする
37. 「データベース (作成したRDS名) の接続の詳細」のダイアログが開かれるので、「マスターパスワード」を控える \
(※このダイアログは一度しか開かれないため、スクリーンショット等で保存を推奨)

### EKS

#### IAMロール作成

以下2つのIAMロールを作成

* クラスターロール(下記リンクの `AWS Management Console` タブの手順を実行)
  <https://docs.aws.amazon.com/ja_jp/eks/latest/userguide/service_IAM_role.html#create-service-role>

* Pod 実行ロール(下記リンクの `AWS Management Console` タブの手順を実行)
  <https://docs.aws.amazon.com/ja_jp/eks/latest/userguide/pod-execution-role.html#create-pod-execution-role>

#### EKSの作成

1. ブラウザでAWS Management Consoleを開き、画面上部の検索欄に「eks」と入力し、サービスの「Elastic Kubernetes Service」をクリックする
2. 画面右上の「クラスターを追加」ボタンをクリックし、「作成」をクリックする
3. クラスター設定の「名前」の入力欄にクラスター名を入力する
4. 「Kubernetes バージョン」から「1.27」(最新のバージョン)を選択する
5. 「クラスターサービスロール」でIAMロール作成で作成した「クラスターロール」を選択する
6. 「シークレットの暗号化」の「KMS を使用して Kubernetes シークレットのエンベロープ暗号化をオンにする」を無効にする
7. 必要に応じて「追加のタグ」から「新しいタグを追加」をクリックし、タグを入力する
8. ネットワーキングの「VPC」から作成したVPCを選択する
9. 「サブネット」で6件のサブネットが選択されていることを確認する(選択されていなければ全て選択する)
10. 「セキュリティグループ」でEKS用に作成したセキュリティグループを選択する
11. 「クラスター IP アドレスファミリーを選択」で「IPv4」を選択する
12. 「Kubernetes サービスの IP アドレス範囲を設定する」を無効にする
13. クラスターエンドポイントアクセスから「パブリックおよびプライベート」を選択する
14. 「次へ」ボタンをクリックする
15. コントロールプレーンのログ記録の各設定を全て有効にする
16. 「次へ」ボタンをクリックする
17. アドオンを選択画面で「kube-proxy」、「CoreDNS」、「Amazon VPC CNI」がデフォルトでインストールされることを確認し、「次へ」ボタンをクリックする
18. 各アドオンのバージョンでそれぞれ最新のバージョン(セレクトボックスをクリックして一番上のもの)を選択し、「次へ」ボタンをクリックする
19. 確認および作成画面で各種設定を確認する(※EKSは作成時と削除時それぞれで約20分程度時間かかるため要確認)
20. 「作成」ボタンをクリックする
21. 約20分経過後、EKSの画面でクラスターが作成されたか確認する

#### Fargateの作成

1. EKSの画面から作成したクラスターをクリックする
2. 画面中央の「コンピューティング」タブをクリックする
3. 一番下の「Fargate プロファイル」から「Fargate プロファイルを追加」をクリックする
4. プロファイル設定の「名前」の入力欄に名前を入力する
5. 「ポッド実行ロール」でIAMロール作成で作成した「Pod 実行ロール」を選択する
6. 「サブネット」で3件のプライベートサブネットが選択されていること確認する(選択されていなければ全て選択する)
7. 「次へ」ボタンをクリックする
8. 確認および作成画面で各種設定を確認する
9. 「作成」ボタンをクリックする
10. 改めて「コンピューティング」タブから作成されたか確認する

### Route53

#### ホストゾーンの作成

1. ブラウザでAWS Management Consoleを開き、画面上部の検索欄に「route53」と入力し、サービスの「Route 53」をクリックする
2. 左のナビゲーターから「ホストゾーン」をクリックする
3. 「ホストゾーンを作成」ボタンをクリックする
4. ホストゾーン設定の「ドメイン名」を入力する
5. 必要に応じて「説明」を入力する
6. 「タイプ」で「パブリックホストゾーン」を選択する
7. 必要に応じて「追加のタグ」から「新しいタグを追加」をクリックし、タグを入力する
8. 「ホストゾーンの作成」ボタンをクリックする
9. ホストゾーンが作成されたことを確認する

#### 証明書の発行

1. ブラウザでAWS Management Consoleを開き、画面上部の検索欄に「cm」と入力し、サービスの「Certificate Manager」をクリックする
2. 画面右上で「リクエスト」ボタンをクリックする
3. 証明書タイプから「パブリック証明書をリクエスト」を選択する
4. 「次へ」ボタンをクリックする
5. ドメイン名の「完全修飾ドメイン名」でドメインを入力をする
6. 検証方法で「DNS検証」を選択する
7. キーアルゴリズムから「RSA 2048」を選択する
8. 必要に応じて「追加のタグ」から「新しいタグを追加」をクリックし、タグを入力する
9. 「リクエスト」ボタンをクリックする
10. リクエスト承認後、証明書が発行されるのを確認
11. 発行された証明書をクリックして、画面中央の「ドメイン」から、「CNAME名」、「CNAEM値」を控えておく

#### 証明書レコードの作成

1. ブラウザでAWS Management Consoleを開き、画面上部の検索欄に「route53」と入力し、サービスの「Route 53」をクリックする
2. 作成したホストゾーンをクリックし、レコードタブから「レコードを作成」ボタンをクリックする
3. ルーティングポリシーから「シンプルルーティング」を選択する
4. 「次へ」ボタンをクリックする
5. 画面中央から「シンプルなレコードを定義」をクリックする
6. シンプルなレコードを定義のダイアログが開いたら、「レコード名」に証明書の発行時に控えた「CNAME名」を入力する
7. 「レコードタイプ」で「CNAME - 別のドメイン名～」を選択する
8. 「値/トラフィックのルーティング先」で、上のセレクトボックスに「レコードタイプに応じたIPアドレスまたは別の値」を選択、下の入力欄に証明書の発行時に控えた「CNAME値」を入力する
9. 「シンプルなレコードを定義」ボタンをクリックする

## keycloakの作成

### ※AWSリソース作成後に実施

* 各手順のコマンドはCloudShell上で実行する\
  (ブラウザでAWS Management Consoleを開き、画面上部の検索欄に「cloudsell」と入力しサービスの「CloudShell」をクリック)
* 当リポジトリをCloudShellのホームディレクトにクローンする\
  ( `git clone git@github.com:c-3lab/mynumbercard-idp.git` 等を実行)

### 1. keycloak-operator のインストール

* [01.keycloak-operator/README.md](01.keycloak-operator/README.md) を参照

### 2. マニフェストファイルの修正、各種手順の実行

* 以下ファイルを参照する
  * [02.keycloak/README.md](./02.keycloak/README.md)
  * [03.control_run_native_app/README.md](./03.control_run_native_app/README.md)

### 3. keycloak用データベース作成

  1. 下記コマンドを実行する

    kubectl run \
     postgres \
     --restart=Never \
     --image=postgres:15.3-alpine \
     --env=POSTGRES_PASSWORD=[RDS完成時に控えたマスターパスワード] \
     --command -- /bin/bash -c -- "while true; do sleep 1; done;"

  2. 下記コマンドを実行し、「postgres」の行が以下のように表示されているかを確認する

   > kubectl get pod

    NAME       READY   STATUS    RESTARTS   AGE
    postgres   1/1     1         0          3m38s

  3. 下記コマンドを実行する

   > kubectl exec -it postgres -- psql -h [作成したRDSのエンドポイント](#2-rdsの作成) -U postgres

  4. `Password for user postgres:` と表示されたら、RDS完成時に控えた[マスターパスワード](#2-rdsの作成)を入力する
  5. 以下のコマンドを実行する

   > // CREATE ROLE と表示されることを確認 \
       CREATE USER keycloak WITH password '[keycloak用のパスワード(※マスターパスワードとは別)]'; \
    // Role name に「keycloak」が作られているかを確認 \
      \du \
    \
    // ALTER DATABASE と表示されることを確認 \
      ALTER DATABASE keycloak OWNER TO keycloak; \
    // Name の keycloak の行の Owner が「keycloak」になっていることを確認 \
      \l \
    \
    // 終了 \
      \q

  6. 以下のコマンドを実行し、各コマンド結果が表示されることを確認する

   > // /home/cloudshell-user と出力することを確認 \
      pwd \
    \
    // secret/keycloak-db-secret created と表示されることを確認 \
      kubectl create secret generic keycloak-db-secret \\\
      --from-literal=username=keycloak \\\
      --from-literal=password=[手順5で設定したkeycloak用のパスワード]

### 4. keycloakの起動

#### Aurora PostgresSQL (Serverless v2) の起動

1. ブラウザを利用し、AWS Management Consoleを開く
2. 画面右上部にあるログインユーザー名の左にあるリージョンが「東京」であることを確認する\
   ※「東京」で無い場合、「リージョン名」、「アジアパシフィック(東京) ap-northeast-1」の順でクリックする
3. 画面上部の検索欄に「rds」と入力し、サービスの「RDS」をクリックする
4. 画面左部のナビゲーションエリアから「データベース」をクリックする
5. DB識別子「作成したRDS名」行の左にあるラジオボタンをクリックする
6. 「アクション▼」-「開始」の順でクリックする
7. データベースが起動するまで10分ほど待機する
8. DB識別子「[作成したRDS名](#2-rdsの作成)」、「[作成したRDS名](#2-rdsの作成)-instance-1」行のステータス列の値がそれぞれ「利用可能」であることを確認する

#### keycloak pods の起動

1. 以下のコマンドを実行する
    > kubectl get deployment.apps/keycloak-operator

2. 以下のように「READY」列が「0/0」であることを確認する
   「READY」列が「1/1」である場合は手順9へ進む

    ```
    NAME                READY   UP-TO-DATE   AVAILABLE   AGE
    keycloak-operator   0/0     0            0           17d
    ```

3. 以下のコマンドを実行し、keycloak-operatorのレプリカ数を1に設定する
    > kubectl scale deployment.apps/keycloak-operator --replicas=1

4. 約2分ほど待機してから以下のコマンドを実行する
    > kubectl get deployment.apps/keycloak-operator

5. 以下のように「READY」列が「1/1」であることを確認する

    ```
    NAME                READY   UP-TO-DATE   AVAILABLE   AGE
    keycloak-operator   1/1     1            1           17d
    ```

6. 以下のコマンドを実行する。
    > kubectl get statefulset.apps/keycloak

7. 以下のように「READY」列が「0/0」であることを確認する

    ```
    NAME       READY   AGE
    keycloak   0/0     17d
    ```

8. 以下のコマンドを実行し、StatefulSet keycloakのレプリカ数を3に設定する
    > kubectl patch keycloak.k8s.keycloak.org/keycloak --type merge -p '{"spec":{"instances":3}}'

9. 約5分ほど待機してから以下のコマンドを実行する
    > kubectl get statefulset.apps/keycloak

10. 以下のように「READY」列が「3/3」であることを確認する

    ```
    NAME       READY   AGE
    keycloak   3/3     17d
    ```
